<!DOCTYPE html>
<html lang="en">
<head>
<!-- HTML header for doxygen 1.8.18 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extending the Model Optimizer with New Primitives - OpenVINO™ Toolkit</title>
<!-- <script type="text/javascript" src="jquery.js?v=405cebc51c254c8b400f2a138dc8f9b3"></script> -->
<!-- JQuery 2.2.4 -->
<script src="jquery-2.2.4.min.js?v=405cebc51c254c8b400f2a138dc8f9b3"></script>
<script type="text/javascript" src="dynsections.js?v=405cebc51c254c8b400f2a138dc8f9b3"></script>
<!-- Bootstrap 4.4.1 -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet"
    type="text/css" />
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.bundle.min.js?v=405cebc51c254c8b400f2a138dc8f9b3"
    type="text/javascript"></script>
<!--  -->
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="/assets/versions_raw.js?v=405cebc51c254c8b400f2a138dc8f9b3"></script>
<script type="text/javascript" src="/assets/openvino-versions_2.js?v=405cebc51c254c8b400f2a138dc8f9b3"></script>
<script type="text/javascript" src="openvino-layout.js?v=405cebc51c254c8b400f2a138dc8f9b3"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/viewerjs/1.6.2/viewer.css" integrity="sha512-Fd7AWkSYX3RBadbJlBrETnOyX5tkcQu2oN+nO11c+kewdhPlNWQ1Hj83W3hN1odgyh+k7rpvvv7IxZq9bRomCg==" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/viewerjs/1.6.2/viewer.min.js?v=405cebc51c254c8b400f2a138dc8f9b3" integrity="sha512-VzJLwaOOYyQemqxRypvwosaCDSQzOGqmBFRrKuoOv7rF2DZPlTaamK1zadh7i2FRmmpdUPAE/VBkCwq2HKPSEQ==" crossorigin="anonymous"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectalign">
   <div id="projectname">
     <a href="<domain_placeholder>" class="homelink-id">
       <img src="/assets/images/int-openvino-wht.svg" alt="OpenVINO™ Toolkit">
       <p>Documentation</p>
      </a>
    </div>
  </div>
</div>
<div id="secondnav">
    <div id="versionsSelector" class="nav-placeholder"></div>
    <div id="download-link" class="nav-placeholder"></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js?v=be771e6d3b47d3e8b7f9ce6a7ab6b839"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Extending the Model Optimizer with New Primitives </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section explains how to register a custom layer in the Model Optimizer, including how to register Proposal as a custom layer. This section also demonstrates how <code>Proposal</code> works as a custom layer.</p>
<p>Model Optimizer loads the model, goes through the topology, and tries to find each layer type in the list of known layers. If the Model Optimizer does not find a layer in that list, it looks for the layer in the list of custom layers. If the Model Optimizer fails to find the layer among the defined custom layers, it registers a Caffe* fallback for for the output shape inference. If the Model Optimizer does not find Caffe and cannot infer shapes, the Model Optimizer fails with an appropriate message.</p>
<p>You must know two things about custom layers with the Model Optimizer:</p>
<ul>
<li>How to map a subgraph in a FW model to a subgraph consisting of Inference Engine layers. For Caffe, the subgraph is a 1-to-1 mapping of a Caffe layer to an Inference Engine layer.</li>
<li>How to infer shapes for unknown subgraphs. This can be either for a step in which the internal representation consists of framework-specific layers, or for a step in which the internal representation consists of Inference Engine layers.</li>
</ul>
<p>You also have the option of a framework fallback for unknown subgraphs, for when the original framework is used for inference of output shapes of operations. The example below demonstrates the case in which the framework is not available or should not be used.</p>
<h2>Preparing an Example Topology</h2>
<blockquote class="doxtable">
<p><b>NOTE</b>: Skip this section if you have a topology with a layer that is not known to the Model Optimizer. </p>
</blockquote>
<p>The information in this section prepares a Caffe* model with the provided, deployment-ready <code>prototxt</code> for a well-known topology called <a href="https://raw.githubusercontent.com/rbgirshick/py-faster-rcnn/master/models/pascal_voc/VGG16/faster_rcnn_end2end/test.prototxt">Faster-R-CNN protoxt</a> to demonstrate the workflow. To use this example, you must have <a href="http://dl.dropboxusercontent.com/s/o6ii098bu51d139/faster_rcnn_models.tgz?dl=0">weights and biases</a> for inference, because <code>prototxt</code> just describes the structure of the topology.</p>
<ol type="1">
<li>Download the <code>.caffemodel</code> and <code>.prototxt</code> files</li>
<li>Run the Model Optimizer on the <code>.caffemodel</code> and <code>.prototxt</code> files: <div class="fragment"><div class="line">python mo.py --input_model VGG16_faster_rcnn_final.caffemodel --input_proto test.prototxt</div>
</div><!-- fragment --></li>
</ol>
<p>You will likely see the error message: </p><div class="fragment"><div class="line">Error parsing text-format caffe.NetParameter: 196:16: Message type &quot;caffe.DropoutParameter&quot; has no field named &quot;scale_train&quot;.</div>
</div><!-- fragment --><p>Whether you see the error depends on your Caffe version. For example, BVLC Caffe does not support the boolean parameter <code>scale_train</code> for the <code>dropout</code> layer. The error message does not matter, because the dropout layer is needed only for training, and the Model Optimizer removes it.</p><ol type="1">
<li>To proceed, comment out these lines in <code>test.prototxt</code>: <div class="fragment"><div class="line">...</div>
<div class="line">layer {</div>
<div class="line">  name: &quot;drop6&quot;</div>
<div class="line">  type: &quot;Dropout&quot;</div>
<div class="line">  bottom: &quot;fc6&quot;</div>
<div class="line">  top: &quot;fc6&quot;</div>
<div class="line">  dropout_param {</div>
<div class="line">    dropout_ratio: 0.5</div>
<div class="line">    # scale_train: false # &lt;-------------- comment out this line</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">layer {</div>
<div class="line">  name: &quot;drop7&quot;</div>
<div class="line">  type: &quot;Dropout&quot;</div>
<div class="line">  bottom: &quot;fc7&quot;</div>
<div class="line">  top: &quot;fc7&quot;</div>
<div class="line">  dropout_param {</div>
<div class="line">    dropout_ratio: 0.5</div>
<div class="line">    # scale_train: false # &lt;-------------- comment out this line</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
</div><!-- fragment --></li>
<li>Run the Model Optimizer on this model again: <div class="fragment"><div class="line">python mo.py --input_model VGG16_faster_rcnn_final.caffemodel --input_proto test.prototxt</div>
</div><!-- fragment --> <pre class="fragment">You get the model successfuly converted to Intermediate Representation, and you can infer it with the Inference Engine.

However, the aim of this tutorial is to demonstrate the way of supporting custom layers not yet supported by the Model Optimizer.
If you want to understand better how Model Optimizer works, remove the extension for layer `Proposal` and follow all steps of this tutorial.
</pre></li>
<li>Remove the extension for layer <code>Proposal</code>: <div class="fragment"><div class="line">mkdir extensions/old</div>
<div class="line">mv extensions/front/caffe/proposal_python_ext.py extensions/old/proposal_python_ext_old.py</div>
<div class="line">mv extensions/ops/proposal_python_example.py extensions/old/proposal_python__example_old.py</div>
</div><!-- fragment --></li>
<li>Now you can run the Model Optimizer on this model once again: <div class="fragment"><div class="line">python mo.py --input_model VGG16_faster_rcnn_final.caffemodel --input_proto test.prototxt</div>
</div><!-- fragment --></li>
</ol>
<p>You will see the message: </p><div class="fragment"><div class="line">[ ERROR ]  Found custom layer proposal. Model Optimizer does not support this layer.</div>
<div class="line">Please, register it in CustomLayersMapping.xml or implement extension.</div>
<div class="line">For more information please refer to Model Optimizer FAQ, question #FAQ45.</div>
</div><!-- fragment --><p>This message means the Model Optimizer can load the model, but is unable to infer the shape and handle the custom layer properties.</p>
<h2>Registering a Custom Layer as a Model Optimizer Extension</h2>
<p>In the following sections, you will learn how to make the Model Optimizer independent from Caffe* when processing a model that has a custom layer. In this example, the custom layer is referred to as the Proposal layer.</p>
<p>Use this section to implement the mapping rules for the <code>Proposal</code> layer attributes and the output shape calculation. As part of these steps, you must first create a class for the <code>Proposal</code> layer and inherit it from general-purpose Op that defines the interface of every new custom layer.</p>
<p>In this section, it is important to understand the <code>Op</code> class and its function. The implementation of this class shows that it expects a graph and attributes to be passed when initializing. The graph and attributes are in <code>&lt;INSTALL_DIR&gt;/deployment_tools/model_optimizer/mo/ops/op.py</code></p>
<p><code>Op</code> keeps the attributes for each operation and contains logic for handling node creation for internal model representation. <code>Op</code> is responsible for dumping each particular operation to the <code>.xml</code> format for the Intermediate Representation. By inheriting from it, the technical items are complete and you concentrate on the specificity of this layer: the attributes it supports and the rules on computing its output shape.</p>
<p>Follow these steps:</p>
<ol type="1">
<li>Create the file <code>python_proposal.py</code> in the directory <code>&lt;INSTALL_DIR&gt;/deployment_tools/model_optimizer/extensions/ops</code>: <div class="fragment"><div class="line">from mo.ops.op import Op</div>
<div class="line">class PythonProposalOp(Op):</div>
<div class="line">    pass</div>
</div><!-- fragment --></li>
<li>Define the name of the operation and make a stub constructor: <div class="fragment"><div class="line">from mo.ops.op import Op</div>
<div class="line">class PythonProposalOp(Op):</div>
<div class="line">    op = &#39;Proposal&#39;</div>
<div class="line">    def __init__(self, graph, attrs):</div>
<div class="line">        super().__init__(graph)</div>
</div><!-- fragment --></li>
<li><p class="startli">Every <code>Op</code> must have three specific fields defined: <code>type</code>, <code>op</code>, and <code>infer</code>. In most cases, the <code>type</code> and <code>op</code> names are the same, and <code>infer</code> is defined as a function to compute the output shape. Reflect these fields in your constructor: </p><div class="fragment"><div class="line">from mo.ops.op import Op</div>
<div class="line">class PythonProposalOp(Op):</div>
<div class="line">    op = &#39;Proposal&#39;</div>
<div class="line">    def __init__(self, graph, attrs):</div>
<div class="line">        mandatory_props = {</div>
<div class="line">            &#39;type&#39;: __class__.op,</div>
<div class="line">            &#39;op&#39;: __class__.op,</div>
<div class="line">            &#39;infer&#39;: None</div>
<div class="line">        }</div>
<div class="line">        super().__init__(graph, mandatory_props, attrs)</div>
</div><!-- fragment --><p class="startli">According to the Intermediate Representation catalog, Proposal layer has the following attributes:</p><ul>
<li><code>pre_nms_topn</code></li>
<li><code>post_nms_topn</code></li>
<li><code>nms_thresh</code></li>
<li><code>feat_stride</code></li>
<li><code>min_size</code></li>
<li><code>base_size</code></li>
<li><code>ratio</code></li>
<li><code>scale</code></li>
</ul>
</li>
<li>In defining supported attribute names, it is best to use the same names as in the original models. The names are similar to parameters and have no connection with the model layer properties. For clarity, you can use the name <code>my_ratio</code> for <code>ratio</code>. Other than defining the list of supported parameters, you can define only the parameters that appear in the Intermediate Representation in the <code>backend_attrs</code> method. <br  />
 Define your attributes: <div class="fragment"><div class="line">class PythonProposalOp(Op):</div>
<div class="line">    # ... constructor</div>
<div class="line">     def supported_attrs(self):</div>
<div class="line">            return [</div>
<div class="line">                &#39;pre_nms_topn&#39;,</div>
<div class="line">                &#39;post_nms_topn&#39;,</div>
<div class="line">                &#39;nms_thresh&#39;,</div>
<div class="line">                &#39;feat_stride&#39;,</div>
<div class="line">                &#39;min_size&#39;,</div>
<div class="line">                &#39;base_size&#39;,</div>
<div class="line">                &#39;ratio&#39;,</div>
<div class="line">                &#39;scale&#39;</div>
<div class="line">            ]</div>
</div><!-- fragment --></li>
<li>Model Optimizer now knows how to create the layer called Proposal when it is in the topology and what attributes this layer has. However, the Model Optimizer does not know how to calculate the output shape of this operation. Define a rule to calculate the output shape: <div class="fragment"><div class="line">import numpy as np</div>
<div class="line">from mo.graph.graph import Node</div>
<div class="line">from mo.ops.op import Op</div>
<div class="line">class PythonProposalOp(Op):</div>
<div class="line">   def __init__(self, graph, attrs):</div>
<div class="line">       mandatory_props = {</div>
<div class="line">           &#39;type&#39;: __class__.op,</div>
<div class="line">           &#39;op&#39;: __class__.op,</div>
<div class="line">           &#39;infer&#39;: PythonProposalOp.calculate_output_shape</div>
<div class="line">       }</div>
<div class="line">       super().__init__(graph, mandatory_props, attrs)</div>
<div class="line">    # ... supported attrs</div>
<div class="line">    @staticmethod</div>
<div class="line">    def calculate_output_shape(node: Node):</div>
<div class="line">        node.out_node().shape = (1, 1, 1, 1) # any Proposal now has always the same output</div>
</div><!-- fragment --></li>
<li>According to the Intermediate Representation catalog, Proposal layer has the following output calculation formula, where shape dynamically depends on the <code>post_nms_topn</code> parameter. <br  />
 Implement the output calculation formula in Python*: <div class="fragment"><div class="line">import numpy as np</div>
<div class="line">class PythonProposalOp(Op):</div>
<div class="line">    # ... static fields</div>
<div class="line">    # ... constructor</div>
<div class="line">    # ... supported attrs</div>
<div class="line">    @staticmethod</div>
<div class="line">    def calculate_output_shape(node: Node):</div>
<div class="line">        input_shape = node.in_node(0).shape</div>
<div class="line">        out_shape = np.array([0, 0], dtype=np.int64)</div>
<div class="line">        # rois blob: holds R regions of interest, each is a 5 - tuple</div>
<div class="line">        # (n, x1, y1, x2, y2) specifying an image batch index n and a</div>
<div class="line">        # rectangle(x1, y1, x2, y2)</div>
<div class="line">        out_shape[0] = input_shape[0] * node.post_nms_topn</div>
<div class="line">        out_shape[1] = 5</div>
<div class="line">        node.out_node(0).shape = out_shape</div>
</div><!-- fragment --> <pre class="fragment">The node does not contain this parameter because it should be initialized in the constructor and in other parameters. The Inference Engine contains the implementation of a Caffe\*-like Proposal layer and works well with the default values from `caffe.proto`:
</pre> <div class="fragment"><div class="line">// Message that stores parameters used by ProposalLayer message ProposalParameter { optional uint32 feat_stride = 1 [default = 16]; optional uint32 base_size = 2 [default = 16]; optional uint32 min_size = 3 [default = 16]; repeated float ratio = 4; repeated float scale = 5; optional uint32 pre_nms_topn = 6 [default = 6000]; optional uint32 post_nms_topn = 7 [default = 300]; optional float nms_thresh = 8 [default = 0.7]; }</div>
</div><!-- fragment --></li>
<li>Change the constructor as follows: <div class="fragment"><div class="line">class PythonProposalOp(Op):</div>
<div class="line">    # ... static fields</div>
<div class="line">    def __init__(self, graph, attrs):</div>
<div class="line">        mandatory_props = {</div>
<div class="line">            &#39;type&#39;: __class__.op,</div>
<div class="line">            &#39;op&#39;: __class__.op,</div>
<div class="line">            &#39;feat_stride&#39;: 16,</div>
<div class="line">            &#39;base_size&#39;: 16,</div>
<div class="line">            &#39;min_size&#39;: 16,</div>
<div class="line">            &#39;ratio&#39;: [0.5, 1, 2],</div>
<div class="line">            &#39;scale&#39;: [8, 16, 32],</div>
<div class="line">            &#39;pre_nms_topn&#39;: 6000,</div>
<div class="line">            &#39;post_nms_topn&#39;: 300,</div>
<div class="line">            &#39;nms_thresh&#39;: 0.7,</div>
<div class="line">            &#39;infer&#39;: PythonProposalOp.calculate_output_shape</div>
<div class="line">        }</div>
<div class="line">        super().__init__(graph, mandatory_props, attrs)</div>
<div class="line">    # ... supported attrs</div>
<div class="line">    # ... calculate output shape</div>
</div><!-- fragment --></li>
</ol>
<p>It is mandatory to call two functions right after the implementation of that class:</p>
<div class="fragment"><div class="line">class ProposalPythonOp(Op):</div>
<div class="line">      ...</div>
<div class="line"> </div>
<div class="line">register_caffe_python_extractor(ProposalPythonOp, &#39;rpn.proposal_layer.ProposalLayer&#39;)</div>
<div class="line">Op.excluded_classes.append(ProposalPythonOp)</div>
</div><!-- fragment --><p>Note that the first call <code>register_caffe_python_extractor(ProposalPythonOp, 'rpn.proposal_layer.ProposalLayer')</code> registers the extension of the layer in the Model Optimizer that will be found by a specific name (it is mandatory to join module name and layer name): <code>'rpn.proposal_layer.ProposalLayer'</code>.</p>
<p>The second call prevents the Model Optimizer from using this extension as if it is an extension for a layer with type <code>Proposal</code>. Otherwise, this layer can be chosen as an implementation of extension that can lead to potential issues.</p>
<p><b>Summary</b></p>
<p>In this section you implemented support for a custom layer with type <code>Python</code> that is <code>Proposal</code> layer in the topology. You learned how to calculate output shape of this layer.</p>
<p>The values of attributes are hardcoded, and in the next section you will learn how to extract these values from original framework model (Caffe model in this case).</p>
<h2>Registering Rules to Pass Extension Layer Properties from a Caffe* Model to the Intermediate Representation</h2>
<p>Model Optimizer now knows how to set the shape of the <code>PythonProposalOp</code> operation, but it is incorrect to initialize attributes with same values for every operation. Instead, the values should be extracted from the original topology. Model Optimizer does not know how to map the custom layer properties to the <code>PythonProposalOp</code>. For this, you must register the <code>FrontExtractorOp</code> instance.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: This step is required only if the layer requires parameters from the original model. </p>
</blockquote>
<ol type="1">
<li>Remove call functions <code>register_caffe_python_extractor</code> and <code>Op.excluded_classes.append</code> from the file with <code>op</code>, because you will implement extracted attributes from prototxt by yourself. There are multiple types of layers in Caffe: for example, <code>Convolution</code> and <code>Pooling</code>. Also, there is a specific type for custom Python* layers called <code>Python</code>. Therefore, it is necessary to distinguish between those 'usual' types of layers and custom ones. If you want to implement extensions for a layer with type different to <code>Python</code>, you need to inherit your class of operation (for example, <code>ProposalFrontExtractor</code>) from <code>FrontExtractorOp</code>. Otherwise, inherit your class of operation from <code>CaffePythonFrontExtractorOp</code>.</li>
<li>Create a file <code>python_proposal_ext.py</code> in the folder <code>&lt;INSTALL_DIR&gt;/deployment_tools/model_optimizer/extensions/front/caffe</code> <div class="fragment"><div class="line"><span class="keyword">from</span> mo.front.extractor <span class="keyword">import</span> CaffePythonFrontExtractorOp</div>
<div class="line"><span class="keyword">class </span>PythonProposalFrontExtractor(CaffePythonFrontExtractorOp):</div>
<div class="line">    <span class="keywordflow">pass</span></div>
</div><!-- fragment --></li>
</ol>
<p>For other layers types, inherit from <code>FrontExtractorOp</code>: </p><div class="fragment"><div class="line"><span class="keyword">from</span> mo.front.extractor <span class="keyword">import</span> FrontExtractorOp</div>
<div class="line"><span class="keyword">class </span>ProposalFrontExtractor(FrontExtractorOp):</div>
<div class="line">    <span class="keywordflow">pass</span></div>
</div><!-- fragment --><p>You will implement extractor for layer with type <code>Python</code>, however, the steps are generally the same for layers with other types.</p><ol type="1">
<li>Specify the operation that the extractor refers to and a specific flag. The flag represents whether the operation should be used by the Model Optimizer or should be excluded from processing: <div class="fragment"><div class="line"><span class="keyword">from</span> mo.front.extractor <span class="keyword">import</span> CaffePythonFrontExtractorOp</div>
<div class="line"><span class="keyword">class </span>PythonProposalFrontExtractor(CaffePythonFrontExtractorOp):</div>
<div class="line">    op = <span class="stringliteral">&#39;rpn.proposal_layer.ProposalLayer&#39;</span></div>
<div class="line">    enabled = <span class="keyword">True</span></div>
</div><!-- fragment --></li>
<li>Register a mapping rule between the original model and the <code>PythonProposalOp</code> attributes by overriding the following function: <div class="fragment"><div class="line"><span class="keyword">from</span> mo.front.extractor <span class="keyword">import</span> CaffePythonFrontExtractorOp</div>
<div class="line"><span class="keyword">from</span> mo.ops.op <span class="keyword">import</span> Op</div>
<div class="line"><span class="keyword">class </span>ProposalPythonFrontExtractor(CaffePythonFrontExtractorOp):</div>
<div class="line">    op = <span class="stringliteral">&#39;rpn.proposal_layer.ProposalLayer&#39;</span></div>
<div class="line">    enabled = <span class="keyword">True</span></div>
<div class="line">    @staticmethod</div>
<div class="line">    <span class="keyword">def </span>extract(node):</div>
<div class="line">        proto_layer = node.pb</div>
<div class="line">        param = proto_layer.python_param <span class="comment"># each layer has a specific parameter, take a look at caffe.proto</span></div>
<div class="line">        python_params = str(param.param_str) <span class="comment"># for Python layers, all params are in param_str</span></div>
<div class="line">        attrs = {</div>
<div class="line">            <span class="stringliteral">&#39;feat_stride&#39;</span>: int(python_params.split(<span class="stringliteral">&#39;:&#39;</span>)[-1])</div>
<div class="line">        }</div>
<div class="line">        <span class="comment"># update the attributes of the node</span></div>
<div class="line">        Op.get_op_class_by_name(<span class="stringliteral">&#39;Proposal&#39;</span>).update_node_stat(node, attrs) <span class="comment"># &lt;------ here goes the name (&#39;Proposal&#39;) of the Operation that was implemented before</span></div>
<div class="line">        <span class="keywordflow">return</span> __class__.enabled</div>
</div><!-- fragment --></li>
</ol>
<blockquote class="doxtable">
<p><b>NOTE:</b> if you implement extension for layer with type different to <code>Python</code>, change the following line: <code>Op.get_op_class_by_name('Proposal').update_node_stat(node, attrs)</code> to this line: <code>Op.get_op_class_by_name(<b>class</b>.op).update_node_stat(node, mapping_rule)</code>. </p>
</blockquote>
<p>You have successfully extracted the parameter <code>feat_stride</code> from <code>prototxt</code>, assuming it is the only parameter in this layer.</p><ol type="1">
<li>To increase the implementation flexibility: <div class="fragment"><div class="line"><span class="keyword">from</span> mo.front.extractor <span class="keyword">import</span> CaffePythonFrontExtractorOp</div>
<div class="line"><span class="keyword">from</span> mo.ops.op <span class="keyword">import</span> Op</div>
<div class="line"><span class="keyword">class </span>PythonProposalFrontExtractor(CaffePythonFrontExtractorOp):</div>
<div class="line">    op = <span class="stringliteral">&#39;rpn.proposal_layer.ProposalLayer&#39;</span></div>
<div class="line">    enabled = <span class="keyword">True</span></div>
<div class="line">    @staticmethod</div>
<div class="line">    <span class="keyword">def </span>extract(node):</div>
<div class="line">        param = node.pb.python_param</div>
<div class="line">        attrs = CaffePythonFrontExtractorOp.parse_param_str(param.param_str)</div>
<div class="line">        Op.get_op_class_by_name(<span class="stringliteral">&#39;Proposal&#39;</span>).update_node_stat(node, attrs)</div>
<div class="line">        <span class="keywordflow">return</span> ProposalPythonFrontExtractor.enabled</div>
</div><!-- fragment --></li>
</ol>
<p>You can successfully convert the model. Open the <code>.xml</code> file and view your code: </p><div class="fragment"><div class="line">...</div>
<div class="line">&lt;<span class="keywordtype">layer</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;42&quot;</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;proposal&quot;</span> <span class="keyword">precision</span>=<span class="stringliteral">&quot;FP32&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;Python&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">data</span> <span class="keyword">base_size</span>=<span class="stringliteral">&quot;16&quot;</span> <span class="keyword">feat_stride</span>=<span class="stringliteral">&quot;16&quot;</span> <span class="keyword">min_size</span>=<span class="stringliteral">&quot;16&quot;</span> <span class="keyword">nms_thresh</span>=<span class="stringliteral">&quot;0.7&quot;</span> <span class="keyword">post_nms_topn</span>=<span class="stringliteral">&quot;300&quot;</span> <span class="keyword">pre_nms_topn</span>=<span class="stringliteral">&quot;6000&quot;</span> <span class="keyword">ratio</span>=<span class="stringliteral">&quot;[0.5, 1, 2]&quot;</span> <span class="keyword">scale</span>=<span class="stringliteral">&quot;[8, 16, 32]&quot;</span>/&gt;</div>
<div class="line">   &lt;<span class="keywordtype">input</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;0&quot;</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;1&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;18&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;15&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;15&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;1&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;36&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;15&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;15&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;2&quot;</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;1&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;3&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">     &lt;/<span class="keywordtype">input</span>&gt;</div>
<div class="line">     &lt;<span class="keywordtype">output</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;3&quot;</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;300&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">            &lt;<span class="keywordtype">dim</span>&gt;5&lt;/<span class="keywordtype">dim</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">output</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">layer</span>&gt;</div>
<div class="line">...</div>
</div><!-- fragment --><p>Look at the output shape of the custom layer you implemented. The shape was calculated according to the rules specified in <code>PythonProposalOp</code>. The <code>ratio</code> and <code>scale</code> properties have the value <code>[0.5, 1, 2]</code> and <code>[8, 16, 32]</code>. They have square brackets because they are originally a repeated parameter. You converted the parameter to a list in <code>PythonProposalOp</code>. Model Optimizer cast the value to a string. According to Python* rules, a list has a string representation of opening and closing square brackets and values joined by commas.</p>
<p>This is not a valid notation for the Intermediate Representation specification, because repeated parameters must be separated by a comma but without the brackets. Therefore, you must override the Model Optimizer default behavior regarding how it handles those parameters during the Intermediate Representation emitting stage, after the optimizations are complete. To do so, implement <code>backend_attrs()</code> in the <code>PythonProposalOp</code> class: </p><div class="fragment"><div class="line">class PythonProposalOp(Op):</div>
<div class="line">    ... other methods</div>
<div class="line">    def backend_attrs(self) -&gt; list:</div>
<div class="line">        &quot;&quot;&quot;</div>
<div class="line">        Gets list of attributes that should appear in resulting IR</div>
<div class="line">        Returns:</div>
<div class="line">            list of attributes names or list of tuples (name of attribute, pre-processing rule)</div>
<div class="line">        &quot;&quot;&quot;</div>
<div class="line">        return [</div>
<div class="line">            (  # a tuple per attribute</div>
<div class="line">                &#39;ratio&#39;,  # name of attribute</div>
<div class="line">                # pre-processing rule in a form of lambda</div>
<div class="line">                # lambda takes a PythonProposalOp node with all defined properties</div>
<div class="line">                # it translates [1,2,3] -&gt; &quot;1,2,3&quot;</div>
<div class="line">                lambda node: &#39;,&#39;.join(map(str, node[&#39;ratio&#39;]))</div>
<div class="line">            ),</div>
<div class="line">            (</div>
<div class="line">                &#39;scale&#39;,</div>
<div class="line">                lambda node: &#39;,&#39;.join(map(str, node[&#39;scale&#39;]))</div>
<div class="line">            ),</div>
<div class="line">            &#39;feat_stride&#39;,</div>
<div class="line">            &#39;base_size&#39;,</div>
<div class="line">            &#39;min_size&#39;,</div>
<div class="line">            &#39;pre_nms_topn&#39;,</div>
<div class="line">            &#39;post_nms_topn&#39;,</div>
<div class="line">            &#39;nms_thresh&#39;</div>
<div class="line">            ]</div>
</div><!-- fragment --><p>The model can now be successfully converted.</p>
<p>Open the <code>.xml</code> file. <code>ratio</code> and <code>scale</code> have the expected correct values <code>0.5,1,2</code> and <code>8,16,32</code>: </p><div class="fragment"><div class="line">...</div>
<div class="line"> </div>
<div class="line">&lt;<span class="keywordtype">layer</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;33&quot;</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;proposal&quot;</span> <span class="keyword">precision</span>=<span class="stringliteral">&quot;FP32&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;Python&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">data</span> <span class="keyword">base_size</span>=<span class="stringliteral">&quot;16&quot;</span> <span class="keyword">feat_stride</span>=<span class="stringliteral">&quot;16&quot;</span> <span class="keyword">min_size</span>=<span class="stringliteral">&quot;16&quot;</span> <span class="keyword">nms_thresh</span>=<span class="stringliteral">&quot;0.7&quot;</span> <span class="keyword">post_nms_topn</span>=<span class="stringliteral">&quot;300&quot;</span> <span class="keyword">pre_nms_topn</span>=<span class="stringliteral">&quot;6000&quot;</span> <span class="keyword">ratio</span>=<span class="stringliteral">&quot;0.5,1,2&quot;</span> <span class="keyword">scale</span>=<span class="stringliteral">&quot;8,16,32&quot;</span>/&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span>&gt;</div>
<div class="line">      ...</div>
<div class="line">    &lt;/<span class="keywordtype">input</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">output</span>&gt;</div>
<div class="line">       ...</div>
<div class="line">    &lt;/<span class="keywordtype">output</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">layer</span>&gt;</div>
<div class="line"> </div>
<div class="line">...</div>
</div><!-- fragment --><blockquote class="doxtable">
<p><b>NOTE</b>: Model Optimizer supports the Faster-R-CNN topology. Run the following command for the same Intermediate Representation: </p>
</blockquote>
<div class="fragment"><div class="line">python mo.py --input_model VGG16_faster_rcnn_final.caffemodel --input_proto test.prototxt --extensions &lt;INSTALL_DIR&gt;/deployment_tools/inference-engine/samples/object_detection_sample/fasterrcnn_extensions</div>
</div><!-- fragment --><p><b>Summary</b></p>
<p>In this section you learned how to:</p>
<ol type="1">
<li>Create a framework-independent extension implementation of the Intermediate Representation custom layer with unified logic for calculating output shapes, specified set of attributes</li>
<li>Use the Framework-Specific property extractor to map original model custom layer properties to the expected properties of the Framework-Independent extension</li>
<li>Manipulate the custom layer properties representation in the resulting Intermediate Representation</li>
</ol>
<p>Files used in this section:</p>
<ul>
<li><code>&lt;INSTALL_DIR&gt;/deployment_tools/model_optimizer/extensions/ops/python_proposal.py</code>:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">from</span> mo.front.extractor <span class="keyword">import</span> attr_getter</div>
<div class="line"><span class="keyword">from</span> mo.graph.graph <span class="keyword">import</span> Node</div>
<div class="line"><span class="keyword">from</span> mo.ops.op <span class="keyword">import</span> Op</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ProposalOp(Op):</div>
<div class="line">    op = <span class="stringliteral">&#39;Proposal&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self, graph: nx.MultiDiGraph, attrs: dict):</div>
<div class="line">        mandatory_props = {</div>
<div class="line">            <span class="stringliteral">&#39;type&#39;</span>: __class__.op,</div>
<div class="line">            <span class="stringliteral">&#39;op&#39;</span>: __class__.op,</div>
<div class="line">            <span class="stringliteral">&#39;post_nms_topn&#39;</span>: 300,  <span class="comment"># default in caffe-shared</span></div>
<div class="line">            <span class="stringliteral">&#39;infer&#39;</span>: ProposalOp.proposal_infer</div>
<div class="line">        }</div>
<div class="line">        super().__init__(graph, mandatory_props, attrs)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>supported_attrs(self):</div>
<div class="line">        <span class="keywordflow">return</span> [</div>
<div class="line">            <span class="stringliteral">&#39;feat_stride&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;base_size&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;min_size&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;ratio&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;scale&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;pre_nms_topn&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;post_nms_topn&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;nms_thresh&#39;</span></div>
<div class="line">        ]</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>backend_attrs(self):</div>
<div class="line">        <span class="keywordflow">return</span> [</div>
<div class="line">            <span class="stringliteral">&#39;feat_stride&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;base_size&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;min_size&#39;</span>,</div>
<div class="line">            (<span class="stringliteral">&#39;ratio&#39;</span>, <span class="keyword">lambda</span> node: attr_getter(node, <span class="stringliteral">&#39;ratio&#39;</span>)),</div>
<div class="line">            (<span class="stringliteral">&#39;scale&#39;</span>, <span class="keyword">lambda</span> node: attr_getter(node, <span class="stringliteral">&#39;scale&#39;</span>)),</div>
<div class="line">            <span class="stringliteral">&#39;pre_nms_topn&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;post_nms_topn&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;nms_thresh&#39;</span>,</div>
<div class="line">        ]</div>
<div class="line"> </div>
<div class="line">    @staticmethod</div>
<div class="line">    <span class="keyword">def </span>proposal_infer(node: Node):</div>
<div class="line">        input_shape = node.in_node(0).shape</div>
<div class="line">        out_shape = np.array([0, 0], dtype=np.int64)</div>
<div class="line">        <span class="comment"># rois blob: holds R regions of interest, each is a 5 - tuple</span></div>
<div class="line">        <span class="comment"># (n, x1, y1, x2, y2) specifying an image batch index n and a</span></div>
<div class="line">        <span class="comment"># rectangle(x1, y1, x2, y2)</span></div>
<div class="line">        out_shape[0] = input_shape[0] * node.post_nms_topn</div>
<div class="line">        out_shape[1] = 5</div>
<div class="line">        node.out_node(0).shape = out_shape</div>
</div><!-- fragment --><ul>
<li><code>&lt;INSTALL_DIR&gt;/deployment_tools/model_optimizer/extensions/front/caffe/python_proposal_ext.py</code>:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">from</span> mo.front.extractor <span class="keyword">import</span> CaffePythonFrontExtractorOp</div>
<div class="line"><span class="keyword">from</span> mo.ops.op <span class="keyword">import</span> Op</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ProposalPythonFrontExtractor(CaffePythonFrontExtractorOp):</div>
<div class="line">    op = <span class="stringliteral">&#39;rpn.proposal_layer.ProposalLayer&#39;</span></div>
<div class="line">    enabled = <span class="keyword">True</span></div>
<div class="line"> </div>
<div class="line">    @staticmethod</div>
<div class="line">    <span class="keyword">def </span>extract(node):</div>
<div class="line">        param = node.pb.python_param</div>
<div class="line">        attrs = CaffePythonFrontExtractorOp.parse_param_str(param.param_str)</div>
<div class="line">        Op.get_op_class_by_name(<span class="stringliteral">&#39;Proposal&#39;</span>).update_node_stat(node, attrs)</div>
<div class="line">        <span class="keywordflow">return</span> ProposalPythonFrontExtractor.enabled</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
    <div class="footer">
      <div id="nav-path" class="navpath"></div>
      <div class="footer-content">
        <div class="opt-notice">For more complete information about compiler optimizations, see our 
        <a class="el" href="https://software.intel.com/articles/optimization-notice">Optimization Notice</a>
        </div>
        <div class="footer-row">
          <ul>
            <li><a href="https://software.intel.com/en-us/forums/computer-vision">Support</a></li>
            <li><a href="/<version_placeholder>/openvino_docs_Legal_Information.html">Legal Information</a></li>
            <li><a href="https://www.intel.com/content/www/us/en/privacy/intel-cookie-notice.html">Cookies and Similar Technologies Notice</a></li>
          </ul>
        </div>
      </div>
    </div>
  </body>
</html>